<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"Game.js.html":{"id":"Game.js.html","title":"Source: Game.js","body":" SkiX Source: Game.js \"use strict\"; import Swal from 'sweetalert2'; import * as Constants from \"../Constants\"; import { wrapperStyle } from './Styles'; import { AssetManager } from \"./AssetManager\"; import { Canvas } from './Canvas'; import { Skier } from \"../Entities/Skier\"; import { Rhino } from \"../Entities/Rhino\"; import { StatsBoard } from './StatsBoard'; import { ObstacleManager } from \"../Entities/Obstacles/ObstacleManager\"; import { Rect } from './Utils'; /* 1. load 2. init 3. run */ export class Game { #_gameWindow = null; // change // pause UpdateGameWindow #_pause = false; #_obstacle = null; #_crashed = false; #_end = false; #_n = 0; #_isEating = false; #_window = null; #_mode = 'easy'; #_gameConsole = null; #_skierSpeed = 10; #_rhinoSpeed = 10; get skierSpeed() { return this.#_skierSpeed; } get rhinoSpeed() { return this.#_rhinoSpeed; } set pause(state) { this.#_pause = state; } get window() { return this.#_window; } get crashed() { return this.#_crashed; } get pause() { return this.#_pause; } set obstacle(state) { this.#_obstacle = state; } get obstacle() { return this.#_obstacle; } get gameOver() { return this.#_end; } constructor({ win, mode, console } = {}) { this.#_mode = mode || 'easy'; if (this.#_mode === 'easy') { this.#_skierSpeed = 5; this.#_rhinoSpeed = 5; } if (console) { this.#_gameConsole = console; } /** * wtf? * win here is a reference to which window object this class relies to. * why? e2e / visual testing. On cypress the application runs in a iframe */ this.#_window = win || window; this.dom = this.#_window.document; this.dom.body.style = wrapperStyle; this.assetManager = new AssetManager(); this.canvas = new Canvas(this.#_window.innerWidth, this.#_window.innerHeight, this.#_window); this.skier = new Skier(0, 0, this); this.rhino = new Rhino(this.#_window.innerWidth / 2, 0, this); this.statsBoard = new StatsBoard(this.#_window); this.obstacleManager = new ObstacleManager(this.#_window); this.dom.addEventListener('keydown', this.handleKeyDown.bind(this)); } init() { this.obstacleManager.placeInitialObstacles(); } resetObstacle() { this.obstacle = null; } async load() { await this.assetManager.loadAssets(Constants.ASSETS); } run() { this.canvas.clearCanvas(); this.updateGameWindow(); this.drawGameWindow(); requestAnimationFrame(this.run.bind(this)); } setGameOver() { this.#_isEating = false; this.#_end = true; if (this.#_gameConsole) { (async () =&gt; { this.#_gameConsole.saveMatch({ distance: this.statsBoard.distance, style: this.statsBoard.style, time: this.statsBoard.time }); this.whatNext(); })(); } } whatNext() { Swal.fire({ title: 'Do you want to play again?', showDenyButton: false, showCancelButton: true, confirmButtonText: 'Yes' // denyButtonText: `Don't save`, }).then((result) =&gt; { /* Read more about isConfirmed, isDenied below */ if (result.isConfirmed) { this.restart(); } else { this.#_window.document.location.reload(); } }); // reload window } restart() { this.#_pause = false; this.#_obstacle = null; this.#_crashed = false; this.#_end = false; this.#_n = 0; this.#_isEating = false; this.skier.restart(); this.rhino.restart(); this.statsBoard.startTime = (new Date()).getTime(); } updateGameWindow() { if (this.#_end) { return; } if (this.pause) { return; } if (this.#_isEating) { return; } // if (this.#_crashed) { // return; // } this.statsBoard.setTime(); const previousGameWindow = this.#_gameWindow; this.#_n += 1; const distance = Math.round(this.#_n / 5); if (!this.skier.isIdle) { this.statsBoard.setDistance(distance); this.statsBoard.setSpeed(this.skier.speed); } else { this.statsBoard.setSpeed(0); } this.statsBoard.setStyle(this.skier.style); this.skier.move(); const timeNow = (new Date()).getTime(); const timeDiffer = (timeNow - this.statsBoard.startTime) / 1000; if (timeDiffer &gt; Constants.RHINO_START_AFTER) { this.rhino.move(); } this.calculateGameWindow(); this.obstacleManager.placeNewObstacle(this.#_gameWindow, previousGameWindow); // change // if is there a hit, then pause updateGameWindow const isHit = this.skier.checkIfSkierHitObstacle(this.obstacleManager, this.assetManager); if (isHit) { if (isHit._assetName === 'jumpRamp') { } else { this.#_crashed = true; this.obstacle = isHit; } } const isEating = this.rhino.checkIfRhinoHitSkier(this.assetManager); if (isEating) { this.skier.assetName = ''; this.statsBoard.setSpeed(0); this.#_isEating = true; setTimeout(this.setGameOver.bind(this), 1500); } } drawGameWindow() { this.canvas.setDrawOffset(this.#_gameWindow.left, this.#_gameWindow.top); this.skier.draw(this.canvas, this.assetManager); this.rhino.draw(this.canvas, this.assetManager); this.obstacleManager.drawObstacles(this.canvas, this.assetManager); } calculateGameWindow() { const skierPosition = this.skier.getPosition(); const left = skierPosition.x - (this.#_window.innerWidth / 2); const top = skierPosition.y - (this.#_window.innerHeight / 2); this.#_gameWindow = new Rect(left, top, left + this.#_window.innerWidth, top + this.#_window.innerHeight); } triggerKeyDown(key = Constants.KEYS.DOWN) { const evt = this.dom.createEvent( 'Events' ); evt.initEvent('keydown', true, true); evt.which = key; evt.keyCode = key; this.dom.dispatchEvent( evt ); } handleKeyDown(event) { if (this.#_isEating) { return; } if (this.#_end) { return; } switch(event.which) { case Constants.KEYS.LEFT: if (this.#_crashed) { this.#_crashed = false; } this.skier.turnLeft(); event.preventDefault(); break; case Constants.KEYS.RIGHT: if (this.#_crashed) { break; } this.skier.turnRight(); event.preventDefault(); break; case Constants.KEYS.UP: if (this.#_crashed) { break; } this.skier.turnUp(); event.preventDefault(); break; case Constants.KEYS.DOWN: if (this.#_crashed) { break; } this.skier.turnDown(); event.preventDefault(); break; case Constants.KEYS.JUMP1: if (this.#_crashed) { break; } this.skier.jump(); event.preventDefault(); break; default: event.preventDefault(); break; } } } Ã— Search results Close "},"GameConsole.js.html":{"id":"GameConsole.js.html","title":"Source: GameConsole.js","body":" SkiX Source: GameConsole.js \"use strict\"; import * as voodux from \"voodux\"; import * as Constants from \"../Constants\"; import { Game } from './Game'; import { RankBoard } from './RankBoard'; import { schema } from '../data/schema'; import Swal from 'sweetalert2'; // styles import { wrapperStyle, controlStyle, buttonControlStyle, scenarioStyle, styleTram, styleSnow } from './Styles'; export class GameConsole { #_window = null; #_dom = null; #_wrapper = null; #_scenario = null; #_snow = null; #_tram = null; #_scenarioY = 0; // vh #_scenarioX = 0; #_controls = null; #_game = null; #_playerName = null; #_dataAPI = null; #_rankBoard = null; get scenarioX() { return this.#_scenarioX; } get scenarioY() { return this.#_scenarioY; } get dataAPI() { return this.#_dataAPI; } constructor(win) { /** * wtf? * win here is a reference to which window object this class relies to. * why? e2e / visual testing. On cypress the application runs in a iframe */ this.#_window = win || window; this.#_dom = this.#_window.document; this.#_dom.body.style = wrapperStyle; this.#_wrapper = this.#_dom.body; this.#_scenarioY = (6000 - this.#_window.innerHeight) * (-1); this.#_scenarioX = - (this.#_window.innerWidth / 2); } #_renderScenario() { this.#_scenario = this.#_window.document.createElement('div'); this.#_scenario.style = scenarioStyle.bind(this)(); this.#_wrapper.appendChild(this.#_scenario); } #_renderSnow() { this.#_snow = this.#_window.document.createElement('div'); this.#_snow.style = styleSnow.bind(this)(); this.#_scenario.appendChild(this.#_snow); } #_renderTram() { this.#_tram = this.#_window.document.createElement('div'); this.#_tram.style = styleTram; this.#_scenario.appendChild(this.#_tram); } #_runScenario() { if (this.#_game) { return; } this.#_scenarioX -= 4; this.#_scenario .style = scenarioStyle.bind(this)(); if (this.#_scenarioX &gt;= this.#_window.innerWidth) { this.#_scenarioX = -this.#_window.innerWidth; } requestAnimationFrame(this.#_runScenario.bind(this)); } #_runSnow() { if (this.#_game) { return; } this.#_scenarioY += 1; this.#_snow .style = styleSnow.bind(this)(); if (this.#_scenarioY &gt;= this.#_window.innerHeight) { this.#_scenarioY = (6000 - this.#_window.innerHeight) * (-1); } requestAnimationFrame(this.#_runSnow.bind(this)); } #_renderControls() { this.#_controls = this.#_window.document.createElement('div'); this.#_controls.style = controlStyle; this.#_controls.innerHTML = controlButtonsTemplate(); this.#_wrapper.appendChild(this.#_controls); this.#_bindButtons(); } #_bindButtons() { document .getElementById(Constants.START_GAME_EASY) .onclick = this.#_startGame.bind(this, 'easy'); document .getElementById(Constants.START_GAME_HARD) .onclick = this.#_startGame.bind(this, 'hard'); document .getElementById(Constants.CHECK_RANK) .onclick = this.#_rankBoard.toogle.bind(this.#_rankBoard); } #_startGame(mode) { // console.log(mode); this.askName().then(() =&gt; { this.#_dom.body.innerHTML = ''; this.#_game = new Game({ win: this.#_window, mode, console: this }); this.#_game.load().then(() =&gt; { this.#_game.init(); this.#_game.run(); }); }); } start() { (async () =&gt; { const foundation = new voodux.Foundation({ name: \"SkiFree\", schemas: { Game: schema } }); const start = await foundation.start(); if (start.error) { alert(start.error); return; } this.#_dataAPI = foundation.data; /* if (!this.askName()) { return; } */ this.#_rankBoard = new RankBoard({ win: this.win, console: this }); this.#_renderScenario(); this.#_renderSnow(); this.#_renderTram(); this.#_renderControls(); this.#_runScenario(); this.#_runSnow(); })(); } async askName() { const { name } = await Swal.fire({ title: 'Player info', input: 'text', inputLabel: 'What is your name?', inputValue: 'Guest', showCancelButton: false, inputValidator: (value) =&gt; { if (!value) { return 'You need to write something!'; } } }); this.#_playerName = name; return this.#_playerName; } async saveMatch({ distance, style, time }) { await this.#_dataAPI.Game.add({ name: this.#_playerName, time, distance, style }); } } function controlButtonsTemplate () { return (/* html */` &lt;button style=\"${buttonControlStyle}\" id=\"${Constants.START_GAME_EASY}\" &gt; start game - easy mode &lt;/button&gt; &lt;button style=\"${buttonControlStyle}\" id=\"${Constants.CHECK_RANK}\" &gt; check rank &lt;/button&gt; &lt;button style=\"${buttonControlStyle}\" id=\"${Constants.START_GAME_HARD}\" &gt; start game - hard mode &lt;/button&gt; `); }; Ã— Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" SkiX SkiX, the SkiFree Game Doc Play online - Demo Run in dev mode npm install npm run dev Run tests on Visual mode npm run cy:open Run tests on Unit mode npm run test Code challenge This project is a answer to the following code challenge: Ceros Ski Code Challenge Changes made after the code being forked: PROJECT SETUP The babel and wepack setup was update to use newer versions. Allowing, for example, the usage of private resources inside Classes. Security issues related to modules being used is also now solved. Added source maps to improve debugging. Added Eslint to enforce best pratices and code quality. jsDoc setup to generate documentation based on comments from source files. BUG FIX After get crashed when hitting an obstacle, the skier should be able to get and be facing to the left side up after pressing the left arrow. BUG FIX There was a bug when starting the game and imediately calling ObstacleManager.placeNewObstacle() method. There were no conditionals checking the value of the variable previousGameWindow. REFACTOR Skier: The property Skier.assetName is moved to Entity class to be able to be used by any class extending the Entity class. Game: FEATURE The skier is now able to jump when pressing the shift key. It original speed is incresed to two times. When jumping the skier does not get crashed if it hit any rock obstacle. FEATURE The Ramp Jump obstacle is now implemented. When hitting the ramp jump the skier behaves like it's jumping. TESTING Deprecated Jest in favor of Cypress to get a real browser environment to test the game. Jest setup would need at least one addon to deal with canvas and you still does not have a real browser environment. This change is now allowing visual testing. Written unit tests to cover initial reported issue. Written unit tests to cover the jump funcionality. The test suite now is now able to be run as unit test and visual testing and unit test mode. REFACTOR The image assets were encoded into base64 strings and stored as js modules and now are they are built and loaded together with the main and unique bundle file. This is a change which improves the game loading and make it easiest to update any asset FEATURE The rhino is up and hungry! Rhino runs from right to left based in skier currently position FEATURE Game Stats Panel Display time Display distance Display speed Display style FEATURE Game console. The game console is the welcome screen allowing the player to select the game mode to start or check the game rank. PROJECT SETUP Continuous integration setup using Circle CI. Online demo is being deployed at vercel. FEATURE Rank Database. It is saving the match data to indexeDB through voodux Notes NOTE 1: Except for the pop up widgets and data persistence features, this game is a VanilaJS implementation. For sure we can decrease the development time and improve the game experience by using 3 party libraries or framework, but the main idea is to show how to do things with pure JS. NOTE 2: Rather building a back end to persist data, I have added voodux to the project to persist data in a local nosql database. NOTE 3: Inside some classes such as Game and GameConsole there is a reference to the browser global window object. It may sounds dumb, but it provides support to visual testing throuhg Cypress. Cypress works by rendering the tested code in a iframe in the right side of the screen when you run it in a non headless mode. Improvement suggestions: Implement better UI for asking player name. Give the player an option after being ate by rhino. Refactor game console. Deprecate voodux usage in favor of native IndexedDB API to reduce the bundle size. Write more unit tests. Write more e2e tests. Code coverage. Code documentation. jsDoc is already set up. Known bugs When rhino is running into skier direction AND if iskier direction There are some cases where you are fast pressing arrows and you are eaten by rhino, the skier reappears in the screen. Ã— Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
